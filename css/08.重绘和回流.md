### 浏览器的重绘和回流（Repaint和Reflow）

> **repaint: **当诸如颜色背景等不会引起页面布局变化，而只需要重新渲染的过程叫做重绘
>
> **reflow: **当render树的一部分或者全部因为大小边距等问题发生改变而需要重建的过程，叫做回流
>
> 回流必定伴随重绘，重绘可以单独出现
>
> 重绘性能优于回流性能

#### 浏览器的渲染过程

1. 解析HTML，生成DOM树，解析CSS，生成CSSOM树
2. 将DOM树和CSSOM树结合，生成渲染树（Render Tree）
3. Layout（回流）：根据生成的渲染树，进行回流（Layout），得到节点的几何信息（位置、大小）
4. Painting（重绘）：根据渲染树以及回流得到的几何信息，得到节点的绝对像素
5. Display：将像素发送给GPU，展示在页面上

##### 构建渲染树的过程

 	1. 从DOM树的根节点开始遍历每个**可见**节点
 	2. 对于每个可见节点，找到CSSOM树中对应的规则，并应用它们
 	3. 根据每个可见节点以及其对应的样式，组合生成渲染树

> 可见节点不包括以下内容：
>
> * 一些不会渲染输出的节点，比如script、meta、link等
> * 一些通过css进行隐藏的节点，比如display:none；_利用visibility和opacity隐藏的节点还是会显示在渲染树上，只有display:none的节点不会显示在渲染树上_

#### 什么会引起回流

1. 页面渲染初始化

2. DOM结构变化，比如添加或删除了某个节点

3. render树的变化，即元素尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）

4. 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片替代

5. 窗口resize事件触发（回流根据视口的大小来决定元素的大小和位置）

6. 最复杂的一种，获取某些属性，引发回流（很多浏览器会对回流做优化，等到足够数量的变化发生，再做一次批处理回流。但是除了render的直接变化。当获取一些属性时，浏览器为了获得正确的值也会触发回流，是的浏览器优化失效）

   这些属性包括

   * offsetTop、offsetLeft、offsetWidth、offsetHeight
   * scrollTop、scrollLeft、scrollWidth、scrollHeight
   * clientTop、clientLeft、clientwith、clientHeight
   * width、height
   * getComputedStyle()
   * getBoundingClientRect()

#### 减少回流和重绘

1. 避免逐项更改样式，最小化重绘和回流。最好一次性更改style属性，或者将样式列表定义为class并一次性更改class属性

   ```js
   const el = document.getElementById("test");
   el.style.padding = '5px';
   el.style.borderLeft = '1px';
   el.style.margin = '5px';
   
   以上代码片段可使用以下方式优化
   // 使用cssText
   const el = document.getElementById("test");
   el.style.cssText += 'border-left: 1px; border-right: 2px;padding: 5px;';
   // 修改CSS的class
   const el = document.getElementById('text');
   el.className += 'active';
   ```

   

2. 批量修改DOM，避免循环操作DOM（可以创建一个documentFragment或div，在它上面应用所有的DOM操作，最后再把它添加到window.document)

   当需要对DOM进行一系列修改时，可以通过以下步骤减少回流重绘次数

   * 使元素脱离文档流
   * 对其进行对此修改
   * 将元素带回文档中

   DOM脱离文档流的三种方式

   * 隐藏元素，应用修改，重新显示

     ```js
     function appendDataToElement(appendToElement, data) {
         let li;
         for(let i = 0; i < data.length; i++) {
             li = document.createElement('li');
             li.textContent = 'text';
             appendToElement.appendChild(li);
         }
     }
     const ul = document.getElementById('list');
     ul.style.display = 'none';
     appendDataToElement(ul, data);
     ul.style.display = 'block';
     ```

     

   * 使用文档片段（document fragment）在当前DOM之外构建一个子树，再把它拷贝回文档

     ```js
     const ul = document.getElementById('list');
     const fragment = document.createDocumentFragment();
     appendDataToElement(fragment, data);
     ul.appendChild(fragment);
     ```

     

   * 将元素元素拷贝至一个脱离文档的节点中，修改节点后，再替换原始的元素

     ```js
     const ul = document.getElementById('list');
     const clone = ul.cloneNode(true);
     appendDataToElement(clone, data);
     up.parentNode.replaceChild(clone, data);
     ```

3. 避免出发同步布局事件，例如多次读取offsetLeft（引起回流的事件）等属性。无法避免则将它们缓存到变量

   ```js
   function initP() {
       for (let i = 0; i < paragraphs.length; i++) {
           paragraphs[i].style.width = box.offsetWidth + 'px';
       }
   }
   // 上述方法不推荐，推荐下面的方法
   const width = box.offsetWidth;
   function initP() {
       for(let i = 0; i < paragraphs.length; i++) {
           paragraphs[i].style.width = width + 'px'
       }
   }
   ```

   

4. 将复杂动画效果绝对定位或固定定位，使他脱离文档流，否则回流代价十分高

5. css3硬件加速（GPU加速）

   > 适用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘。但是对于动画的其他属性，比如background-color这些还是会引起回流重绘，不过它还是可以提升这些动画的性能

   如何使用

   常见的触发硬件加速的css属性

   * transform
   * opacity
   * filters
   * Will-change

   要注意的问题

   * 过多地开启硬件加速可能会耗费较多的内存，因此什么时候开启硬件加速，给多少元素开启硬件加速，需要用测试结果说话
   * 在GPU渲染字体会导致抗锯齿无效。这是因为 GPU 和 CPU 具有不同的渲染机制，即使最终硬件加速停止了，文本还是会在动画期间显示得很模糊。

#### 拓展

> display：none指的是元素完全不陈列出来，不占据空间，涉及到了DOM结构，故产生reflow和repaint；
>
> visibility：hidden指的是元素不可见但存在，保留空间不影响结构，故只产生repaint

#### 参考链接

https://www.cnblogs.com/dll-ft/p/5810639.html

https://zhuanlan.zhihu.com/p/77520334

https://juejin.cn/post/6844903903826296846

